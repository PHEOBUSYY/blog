layout: "post"
title: "Programming Principles 翻译"
date: "2016-11-05 18:11"
---

## 编程规则

### 通用的

#### KISS(keep It Simple Stupid)

大部分保持简单的系统要比复杂的系统运行的更好

为什么呢？
- 更少的代码消耗更少的时间，有更少的bug，并且更容易修改
- 大道至简（Simplicity is the ultimate sophistication）
- 最完美的不是没有什么可以增加的，而是没有什么是可以删减的，也就是最终的精简

#### YAGNI
YAGNI是“你不会需要他的：不要实现它除非你确实需要它”

为什么呢？

- 任何在未来才可能用到的功能，意味着会浪费当前迭代的精力
- 它会导致代码臃肿（bloat），使软件更加的庞杂

如何做？

- 永远去实现你确实需要的事物，永远不要去实现你只是预见到未来才能用到的事物

#### 仅仅做可以运行的最简单的事物

为什么呢？
如果我们作用于问题的真正所在，就可以最大化的解决问题

如何做呢？
问问你自己“什么才是可以使它起作用的最简单的方式”

#### 关注隔离

关注隔离是一种把程序分离成清晰的层次的设计原则，致使每一层关注不同的位置。比如业务逻辑是一种关注方向，而UI又是另一个方向的关注
调整UI不应该影响业务逻辑，同理反之。

'''
引用自  Edsger W. Dijkstra（1974）：
  我所说的“关注隔离”是唯一的一种可以使思维想法有序的技术，虽然不一定完美，这是一种“使你聚焦于某些方面”：这并不是说忽略其它的方面，而只是说在正确的关注点上
  工作，其它方面都是不可见的。
'''
为什么呢？
- 更容易的开发和维护系统应用
- 如果分层合理，那么每一个独立的层都可以被复用，开发和升级

如何做？
- 尽可能的分解系统为不同的独立模块

#### 保证事物DRY（dont repeat yourself）
在程序中每一个元素都必须保证唯一性，无歧义，独一代表性

每个定义在源代码中应该只有一份实现。如果同样的功能实现出现在不同的地方，最好是把他们合并成一个公共的的抽象

为什么呢？
- 重复（不管是有意无意）都会导致维护困难，未知的因素和逻辑混乱
- 单一元素的调整不应该引起不想关逻辑调整
- 通常逻辑相关的改动应该是可预测和均匀的，并且保持同步

如何做？
- 把业务逻辑，表达式，if表达式，数学运算等应该只出现在一个地方
- 在程序中找出某一功能点的单一明确的定义,然后通过该定义来生成可以用的实例
- rule of three

#### 为修改人员编写代码

为什么呢?

- 对任何工程而言维护都是需要花费很多代价的

如何做?
- 做一个维护者
- 在编写代码的时候想想修改你代码的是一个有严重暴力倾向的精神病患者,并且他还知道你住在哪里
- 在编写代码和提交的时候想想菜鸟会非常乐意从你的代码中学习
- 不要使我思考
- 使用最小惊讶原则

#### 避免过早优化
摘自 Donald Knuth:
>程序员浪费大量的精力在思考或者担心程序中非紧急模块的效率,并且被认为包含消极冲突
> 我们应该忘记小小的效率提升,大约百分之97的概率:过早优化是万恶之源

明白什么是"过早",和不是"过早"是问题的核心

为什么呢?
- 你预先不知道到底问题的瓶颈在哪里
- 优化过后,代码变得难以阅读和修改
如何做?
- 是它工作快而正确
- 不要优化知道你确实并且知道瓶颈所在

#### 最小化耦合

耦合是指功能和模块之间等层级相互依赖;低耦合是好的,换句话说,耦合是指单元B有可能会停止是由在单元A中有未知的改动而造成的.

为什么呢?
- 对一个模块的某处修改一般会引起其他的模块的连锁反应
- 组装模块需要更多的精力和时间由于内部模块之间的依赖
- 模块会变得特别难以复用和测试由于依赖模块也必须被引入
- 开发人员可能会很恐惧修改代码因为他们也不确定会引起其他问题

### 迪米特法则
不要和陌生人说话

为什么呢?
- 这样经常会导致紧密的耦合
- 这样会暴露更多的实现细节

如何做?
对象中的方法只应该调用的方法有:
- 对象本身
- 方法中的参数
- 方法中创建的对象
- 对象中的成员变量和属性

### 组合优于继承
为什么呢?
- 类之间的耦合更少
- 使用继承,子类容易造成猜测,违背里氏替换原则


如何做?
- 测试能否符合里氏替换来决定使用继承
- 当二者关系是 "has a " 或 "use a" 时使用组合,当二者关系是 "is a" 时使用继承

### 正交性
正交性的核心思想是两个无关的概念不应该在系统中相互关联

### 健壮性原则
对你所做的持有保守态度,对接受到别人的东西保持宽容态度.
合作服务以来与相互之间的接口,通常情况下接口会以进化到不确定的数据为结尾.一个幼稚的实现一般是拒绝合作如果收到一个不太严格的数据格式.而老练的接口通常情况下会忽略它无法识别的数据继续执行.

为什么呢?
- 为了可以升级服务你需要确认提供者可以做出调整来支持各种需求特别是在对现有客户端引起最小调整的情况下.

如何做呢?
发送给其他系统的代码应该转换为明确的格式,但是从别的地方接收到的数据应该代码应该同时也可以接受含义不太明确的数据

### 高内聚
模块的内聚指的是指他们的职责是一个有意义的集合.越高内聚越好.

如果不这样会怎么样?
- 增加模块间的理解难度
- 增加修改难度,因为修改当前领域的逻辑会导致其他模块的变化.
- 影响组件模块的复用性

如何做呢?
组件相关的功能应该共享一个单一职责

### LSP里氏替换原则
LSP期望的对象行为是:
程序中的对象转换为子类对象之后是无需做任何调整的,也就是子类可以完美替换父类

### 开闭原则
软件中的实例应该对修改关闭,对扩展开放.当然在不修改源代码的基础上的修改是可以的

为什么呢?
通过对现有代码的最小改动来保证可维护性和稳定性

如何做呢?
- 书写可以扩展的实体(相反的是可以被修改的类)
- 只是扩展需要调整的地方,其他的地方隐藏
### 单一职责原则
一个只应该有一个修改的原因

为什么呢?
修改只应该对于必要的类或者类

如何做?
遵守 Curly’s Law.

### 隐藏实现细节
软件应该隐藏接口的实现细节,不要暴露不必要的实现细节

为什么呢?
当实现细节调整后,实现接口的客户端不应该做调整

如何做?
- 最小化类和成员的可访问性
- 不要在公共的地方暴露数据
- 不要在一个类接口中提供私有的实现
- 减少耦合来隐藏更多的实现细节
###  Curly’s Law
Curly’s Law是一个关于代码选择单一,清晰的目标:只做一件事

### 封装变化
一个良好的设计定义是对变化的封装于API之后,当发生预期的变化时,修改只是局限于当前.
为什么呢?
- 修改发生的时候保证最小的修改范围

如何做?
- 把各种概念封装与API之后
- 尽可能的把各个概念放入自己的所属模块中

### 接口隔离原则
将臃肿的接口拆分成多个小的独立的接口.接口应该更多的依赖于调用它的代码而不是实现它的代码.
为什么呢?
- 如果一个类实现了一个它不需要的接口,调用者需要知道这个实现方法是永远不会被调用的.
如何做呢?
- 避免臃肿接口,类不应该实现违背了单一职责原则的接口

### 童子军规则
在美国有一条童子军规适用于我们的职业:当你离开一个地方的时候,保证这个地方比你来的时候更干净.
为什么呢?
- 当你对现存的代码做调整的时候,代码质量往往在下降,累计技术债务.遵守童子军军规可以使我们更加关注提交代码的质量,技术债务会被连续的重构减少,无论多么小.
如何做呢?
- 每次提交保证没有降低代码质量
- 每当发现一些不够清晰的代码的时候,应该抓住机会来把它整理的更加清晰

### 命令查询分离
这条原则指的是每一个方法都应该作为一条命令去执行或查询并返回数据.问一个问题不应该修改答案
有了这个原则,程序员可以更有信心的编码.查询方法可以再任何地方以任何顺序使用,因为他们不会改变状态.使用命令,必须更加小心.
为什么呢?
- 通过将方法清楚地分离成查询和命令,程序员可以在不知道每个方法的实现细节的情况下用额外的置信度进行编码

如何做?
- 把每一个方法当做一个查询或者命令
- 遵循命名定义,隐含的说明该方法是一个命令还是查询.
